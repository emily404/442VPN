import random

# public key exchange using the Diffie-Hellman algorithm
# two parties each pick secret random integer a and b and publicly decide base b and modulo p coprime to b
# session key is generated as b^ab mod p
# each player compute "half keys" b ^ a and b ^ b respectively, and exchange them
# take the half keys and take it to the power of b or a respectively to get b^ab mod p
class DiffieHellman:

	SECRET_MAX_VAL = pow(2, 10)
	SECRET_MIN_VAL = pow(2, 0)

	DEFAULT_PRIME = 160397022681332837982501360622187903385636099663926916987196394082067610996409020846117501020097391882057277902529677187331483396135478323546135349929127937237820770355298238213254789834673504654412980000535281273079087527379521206298312003725496496456835503279237143483535191480253697768641165270168873

	def __init__(self, modulo, base):
		self.modulo = modulo
		self.base = base
		# print "[DiffieHellman] new instance created with modulo: \n" + str(modulo) +" \nbase: "+str(base)

	@classmethod
	def defaultInstance(self):
		return self(self.DEFAULT_PRIME, 2)

	def getParameters(self):
		return (self.modulo, self.base)

# generate a new secret, 
	def genSecret(self):
		self.secret = random.randint(self.SECRET_MIN_VAL, self.SECRET_MAX_VAL)
		# print "[DiffieHellman] new secret generated " + str(self.secret)

# generate key with secret generated by method genSecret
# 
	def partialSessionKeyGen(self):
		#gen secret
		# print "[DiffieHellman] generating new secret"
		self.genSecret()
		sKey = pow(self.base, self.secret, self.modulo)
		# print "[DiffieHellman] semi-key generated " + str(sKey)
		return (sKey, self.secret)


	def computeTotalSessionKey(self, sKey):
		s = pow(sKey, self.secret, self.modulo)
		# print "[DiffieHellman] generating common key: "+str(s)
		return s







